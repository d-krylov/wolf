
#ifndef WOLF_MASKS_H
#define WOLF_MASKS_H

// includes
#include "mask.h"

namespace Wolf {

enum class Flags {};

// content
using FramebufferCreateMask = Mask<FramebufferCreateMaskBits>;
using QueryPoolCreateMask = Mask<Flags>;
using RenderPassCreateMask = Mask<RenderPassCreateMaskBits>;
using SamplerCreateMask = Mask<SamplerCreateMaskBits>;
using PipelineLayoutCreateMask = Mask<PipelineLayoutCreateMaskBits>;
using PipelineCacheCreateMask = Mask<PipelineCacheCreateMaskBits>;
using PipelineDepthStencilStateCreateMask = Mask<Flags>;
using PipelineDynamicStateCreateMask = Mask<Flags>;
using PipelineColorBlendStateCreateMask = Mask<Flags>;
using PipelineMultisampleStateCreateMask = Mask<Flags>;
using PipelineRasterizationStateCreateMask = Mask<Flags>;
using PipelineViewportStateCreateMask = Mask<Flags>;
using PipelineTessellationStateCreateMask = Mask<Flags>;
using PipelineInputAssemblyStateCreateMask = Mask<Flags>;
using PipelineVertexInputStateCreateMask = Mask<Flags>;
using PipelineShaderStageCreateMask = Mask<PipelineShaderStageCreateMaskBits>;
using DescriptorSetLayoutCreateMask = Mask<DescriptorSetLayoutCreateMaskBits>;
using BufferViewCreateMask = Mask<Flags>;
using InstanceCreateMask = Mask<InstanceCreateMaskBits>;
using DeviceCreateMask = Mask<Flags>;
using DeviceQueueCreateMask = Mask<DeviceQueueCreateMaskBits>;
using QueueMask = Mask<QueueMaskBits>;
using MemoryPropertyMask = Mask<MemoryPropertyMaskBits>;
using MemoryHeapMask = Mask<MemoryHeapMaskBits>;
using AccessMask = Mask<AccessMaskBits>;
using BufferUsageMask = Mask<BufferUsageMaskBits>;
using BufferCreateMask = Mask<BufferCreateMaskBits>;
using ShaderStageMask = Mask<ShaderStageMaskBits>;
using ImageUsageMask = Mask<ImageUsageMaskBits>;
using ImageCreateMask = Mask<ImageCreateMaskBits>;
using ImageViewCreateMask = Mask<ImageViewCreateMaskBits>;
using PipelineCreateMask = Mask<PipelineCreateMaskBits>;
using ColorComponentMask = Mask<ColorComponentMaskBits>;
using FenceCreateMask = Mask<FenceCreateMaskBits>;
using SemaphoreCreateMask = Mask<Flags>;
using FormatFeatureMask = Mask<FormatFeatureMaskBits>;
using QueryControlMask = Mask<QueryControlMaskBits>;
using QueryResultMask = Mask<QueryResultMaskBits>;
using ShaderModuleCreateMask = Mask<Flags>;
using EventCreateMask = Mask<EventCreateMaskBits>;
using CommandPoolCreateMask = Mask<CommandPoolCreateMaskBits>;
using CommandPoolResetMask = Mask<CommandPoolResetMaskBits>;
using CommandBufferResetMask = Mask<CommandBufferResetMaskBits>;
using CommandBufferUsageMask = Mask<CommandBufferUsageMaskBits>;
using QueryPipelineStatisticMask = Mask<QueryPipelineStatisticMaskBits>;
using MemoryMapMask = Mask<MemoryMapMaskBits>;
using MemoryUnmapMask = Mask<MemoryUnmapMaskBits>;
using ImageAspectMask = Mask<ImageAspectMaskBits>;
using SparseMemoryBindMask = Mask<SparseMemoryBindMaskBits>;
using SparseImageFormatMask = Mask<SparseImageFormatMaskBits>;
using SubpassDescriptionMask = Mask<SubpassDescriptionMaskBits>;
using PipelineStageMask = Mask<PipelineStageMaskBits>;
using SampleCountMask = Mask<SampleCountMaskBits>;
using AttachmentDescriptionMask = Mask<AttachmentDescriptionMaskBits>;
using StencilFaceMask = Mask<StencilFaceMaskBits>;
using CullModeMask = Mask<CullModeMaskBits>;
using DescriptorPoolCreateMask = Mask<DescriptorPoolCreateMaskBits>;
using DescriptorPoolResetMask = Mask<Flags>;
using DependencyMask = Mask<DependencyMaskBits>;
using SubgroupFeatureMask = Mask<SubgroupFeatureMaskBits>;
using IndirectCommandsLayoutUsageMask = Mask<IndirectCommandsLayoutUsageMaskBits>;
using IndirectStateMask = Mask<IndirectStateMaskBits>;
using GeometryMask = Mask<GeometryMaskBits>;
using GeometryInstanceMask = Mask<GeometryInstanceMaskBits>;
using BuildAccelerationStructureMask = Mask<BuildAccelerationStructureMaskBits>;
using PrivateDataSlotCreateMask = Mask<Flags>;
using AccelerationStructureCreateMask = Mask<AccelerationStructureCreateMaskBits>;
using DescriptorUpdateTemplateCreateMask = Mask<Flags>;
using PipelineCreationFeedbackMask = Mask<PipelineCreationFeedbackMaskBits>;
using PerformanceCounterDescriptionMask = Mask<PerformanceCounterDescriptionMaskBits>;
using AcquireProfilingLockMask = Mask<AcquireProfilingLockMaskBits>;
using SemaphoreWaitMask = Mask<SemaphoreWaitMaskBits>;
using PipelineCompilerControlMask = Mask<PipelineCompilerControlMaskBits>;
using ShaderCorePropertiesMask = Mask<ShaderCorePropertiesMaskBits>;
using DeviceDiagnosticsConfigMask = Mask<DeviceDiagnosticsConfigMaskBits>;
using AccessMask2 = Mask<AccessMaskBits2>;
using PipelineStageMask2 = Mask<PipelineStageMaskBits2>;
using AccelerationStructureMotionInfoMask = Mask<Flags>;
using AccelerationStructureMotionInstanceMask = Mask<Flags>;
using FormatFeatureMask2 = Mask<FormatFeatureMaskBits2>;
using RenderingMask = Mask<RenderingMaskBits>;
using MemoryDecompressionMethodMask = Mask<MemoryDecompressionMethodMaskBits>;
using BuildMicromapMask = Mask<BuildMicromapMaskBits>;
using MicromapCreateMask = Mask<MicromapCreateMaskBits>;
using DirectDriverLoadingMask = Mask<Flags>;
using PipelineCreateMask2 = Mask<PipelineCreateMaskBits2>;
using BufferUsageMask2 = Mask<BufferUsageMaskBits2>;
using CompositeAlphaMask = Mask<CompositeAlphaMaskBits>;
using DisplayPlaneAlphaMask = Mask<DisplayPlaneAlphaMaskBits>;
using SurfaceTransformMask = Mask<SurfaceTransformMaskBits>;
using SwapchainCreateMask = Mask<SwapchainCreateMaskBits>;
using DisplayModeCreateMask = Mask<Flags>;
using DisplaySurfaceCreateMask = Mask<Flags>;
using AndroidSurfaceCreateMask = Mask<Flags>;
using ViSurfaceCreateMask = Mask<Flags>;
using WaylandSurfaceCreateMask = Mask<Flags>;
using Win32SurfaceCreateMask = Mask<Flags>;
using XlibSurfaceCreateMask = Mask<Flags>;
using XcbSurfaceCreateMask = Mask<Flags>;
using DirectFBSurfaceCreateMask = Mask<Flags>;
using IOSSurfaceCreateMask = Mask<Flags>;
using MacOSSurfaceCreateMask = Mask<Flags>;
using MetalSurfaceCreateMask = Mask<Flags>;
using ImagePipeSurfaceCreateMask = Mask<Flags>;
using StreamDescriptorSurfaceCreateMask = Mask<Flags>;
using HeadlessSurfaceCreateMask = Mask<Flags>;
using ScreenSurfaceCreateMask = Mask<Flags>;
using PeerMemoryFeatureMask = Mask<PeerMemoryFeatureMaskBits>;
using MemoryAllocateMask = Mask<MemoryAllocateMaskBits>;
using DeviceGroupPresentModeMask = Mask<DeviceGroupPresentModeMaskBits>;
using DebugReportMask = Mask<DebugReportMaskBits>;
using CommandPoolTrimMask = Mask<Flags>;
using ExternalMemoryHandleTypeMask = Mask<ExternalMemoryHandleTypeMaskBits>;
using ExternalMemoryFeatureMask = Mask<ExternalMemoryFeatureMaskBits>;
using ExternalMemoryHandleTypeMask = Mask<ExternalMemoryHandleTypeMaskBits>;
using ExternalMemoryFeatureMask = Mask<ExternalMemoryFeatureMaskBits>;
using ExternalSemaphoreHandleTypeMask = Mask<ExternalSemaphoreHandleTypeMaskBits>;
using ExternalSemaphoreFeatureMask = Mask<ExternalSemaphoreFeatureMaskBits>;
using SemaphoreImportMask = Mask<SemaphoreImportMaskBits>;
using ExternalFenceHandleTypeMask = Mask<ExternalFenceHandleTypeMaskBits>;
using ExternalFenceFeatureMask = Mask<ExternalFenceFeatureMaskBits>;
using FenceImportMask = Mask<FenceImportMaskBits>;
using SurfaceCounterMask = Mask<SurfaceCounterMaskBits>;
using PipelineViewportSwizzleStateCreateMask = Mask<Flags>;
using PipelineDiscardRectangleStateCreateMask = Mask<Flags>;
using PipelineCoverageToColorStateCreateMask = Mask<Flags>;
using PipelineCoverageModulationStateCreateMask = Mask<Flags>;
using PipelineCoverageReductionStateCreateMask = Mask<Flags>;
using ValidationCacheCreateMask = Mask<Flags>;
using DebugUtilsMessageSeverityMask = Mask<DebugUtilsMessageSeverityMaskBits>;
using DebugUtilsMessageTypeMask = Mask<DebugUtilsMessageTypeMaskBits>;
using DebugUtilsMessengerCreateMask = Mask<Flags>;
using DebugUtilsMessengerCallbackDataMask = Mask<Flags>;
using DeviceMemoryReportMask = Mask<Flags>;
using PipelineRasterizationConservativeStateCreateMask = Mask<Flags>;
using DescriptorBindingMask = Mask<DescriptorBindingMaskBits>;
using ConditionalRenderingMask = Mask<ConditionalRenderingMaskBits>;
using ResolveModeMask = Mask<ResolveModeMaskBits>;
using PipelineRasterizationStateStreamCreateMask = Mask<Flags>;
using PipelineRasterizationDepthClipStateCreateMask = Mask<Flags>;
using ToolPurposeMask = Mask<ToolPurposeMaskBits>;
using SubmitMask = Mask<SubmitMaskBits>;
using ImageFormatConstraintsMask = Mask<Flags>;
using HostImageCopyMask = Mask<HostImageCopyMaskBits>;
using GraphicsPipelineLibraryMask = Mask<GraphicsPipelineLibraryMaskBits>;
using ImageCompressionMask = Mask<ImageCompressionMaskBits>;
using ImageCompressionFixedRateMask = Mask<ImageCompressionFixedRateMaskBits>;
using DeviceAddressBindingMask = Mask<DeviceAddressBindingMaskBits>;
using OpticalFlowGridSizeMask = Mask<OpticalFlowGridSizeMaskBits>;
using OpticalFlowUsageMask = Mask<OpticalFlowUsageMaskBits>;
using OpticalFlowSessionCreateMask = Mask<OpticalFlowSessionCreateMaskBits>;
using OpticalFlowExecuteMask = Mask<OpticalFlowExecuteMaskBits>;
using FrameBoundaryMask = Mask<FrameBoundaryMaskBits>;
using PresentScalingMask = Mask<PresentScalingMaskBits>;
using PresentGravityMask = Mask<PresentGravityMaskBits>;
using ShaderCreateMask = Mask<ShaderCreateMaskBits>;
using PhysicalDeviceSchedulingControlsMask = Mask<PhysicalDeviceSchedulingControlsMaskBits>;
using VideoCodecOperationMask = Mask<VideoCodecOperationMaskBits>;
using VideoCapabilityMask = Mask<VideoCapabilityMaskBits>;
using VideoSessionCreateMask = Mask<VideoSessionCreateMaskBits>;
using VideoSessionParametersCreateMask = Mask<Flags>;
using VideoBeginCodingMask = Mask<Flags>;
using VideoEndCodingMask = Mask<Flags>;
using VideoCodingControlMask = Mask<VideoCodingControlMaskBits>;
using VideoDecodeUsageMask = Mask<VideoDecodeUsageMaskBits>;
using VideoDecodeCapabilityMask = Mask<VideoDecodeCapabilityMaskBits>;
using VideoDecodeMask = Mask<Flags>;
using VideoDecodeH264PictureLayoutMask = Mask<VideoDecodeH264PictureLayoutMaskBits>;
using VideoEncodeMask = Mask<VideoEncodeMaskBits>;
using VideoEncodeUsageMask = Mask<VideoEncodeUsageMaskBits>;
using VideoEncodeContentMask = Mask<VideoEncodeContentMaskBits>;
using VideoEncodeCapabilityMask = Mask<VideoEncodeCapabilityMaskBits>;
using VideoEncodeFeedbackMask = Mask<VideoEncodeFeedbackMaskBits>;
using VideoEncodeRateControlMask = Mask<Flags>;
using VideoEncodeRateControlModeMask = Mask<VideoEncodeRateControlModeMaskBits>;
using VideoChromaSubsamplingMask = Mask<VideoChromaSubsamplingMaskBits>;
using VideoComponentBitDepthMask = Mask<VideoComponentBitDepthMaskBits>;
using VideoEncodeH264CapabilityMask = Mask<VideoEncodeH264CapabilityMaskBits>;
using VideoEncodeH264StdMask = Mask<VideoEncodeH264StdMaskBits>;
using VideoEncodeH264RateControlMask = Mask<VideoEncodeH264RateControlMaskBits>;
using VideoEncodeH265CapabilityMask = Mask<VideoEncodeH265CapabilityMaskBits>;
using VideoEncodeH265StdMask = Mask<VideoEncodeH265StdMaskBits>;
using VideoEncodeH265RateControlMask = Mask<VideoEncodeH265RateControlMaskBits>;
using VideoEncodeH265CtbSizeMask = Mask<VideoEncodeH265CtbSizeMaskBits>;
using VideoEncodeH265TransformBlockSizeMask = Mask<VideoEncodeH265TransformBlockSizeMaskBits>;

} // end namespace Wolf

#endif // WOLF_MASKS_H
